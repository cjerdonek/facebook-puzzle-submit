#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2010 Chris Jerdonek. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# * The names of the copyright holders may not be used to endorse or promote
#   products derived from this software without specific prior written
#   permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

"""
A script for submitting puzzle solutions to the Facebook PuzzleBot.

For help documentation, execute this script with the -h or --help option.

"""

import datetime
from email import Encoders
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.utils import COMMASPACE
import getpass
import logging
from optparse import OptionParser
import os
import smtplib
import sys
import tarfile


_log = logging.getLogger("fbsubmit")

SMTP_HOST = "smtp.gmail.com"
SMTP_PORT = 587

# Consult the setup section of the help documentation for information
# on the two configuration values below.
SENDER_EMAIL_ADDRESS = ""
TEST_EMAIL_ADDRESS = ""

SENDER_ENV_NAME = "FACEBOOK_PUZZLE_SENDER_EMAIL_ADDRESS"
TEST_ENV_NAME = "FACEBOOK_PUZZLE_TEST_EMAIL_ADDRESS"

DEBUG_OPTION = "-v"
EXCLUDE_FROM_TAR = [".pyc"]
LIB_DIRECTORY_NAME = "lib"
REAL_SUBMISSION_ADDRESS = "1051962371@fb.com"

VALID_PUZZLE_NAMES = [
    "battleship",
    "breathalyzer",
    "dancebattle",
    "dinoisland",
    "facebull",
    "fridgemadness",
    "gattaca",
    "hoppity",
    "liarliar",
    "meepmeep",
    "peaktraffic",
    "rushhour",
    "simonsays",
    "smallworld",
    "sophie",
    "swarm",
    "usrbincrash",
    ]

# Escape the leading "%" since "p" is not a valid format character.
# The optparse module, however, recognizes "%prog" and replaces it
# with the current script name.
USAGE = """%%prog [options] directory

This script sends to the Facebook PuzzleBot a puzzle solution contained in
the given directory.

The script also CC's the solution to the sender.

Setup:

You will need to configure the sender and test e-mail addresses prior
to using this script.

The sender e-mail address is the e-mail address from which to send
puzzle solutions to Facebook (i.e. the "From:" for the e-mails sent to
Facebook).

The test e-mail address is the e-mail address to use for testing this
script.  When running this script in "test mode," the script e-mails
the puzzle solution to the test e-mail address instead of to Facebook.
Consult the rest of the help documentation for information on how
to run the script in "real mode" vs. "test mode."

You can configure the sender and test e-mail addresses in two ways.
The simplest way is to modify the script code itself by setting the
script's SENDER_EMAIL_ADDRESS and TEST_EMAIL_ADDRESS constants to the
desired values.

The second way is to set corresponding environment variables.
If you are familiar with setting environment variables, you can store
the e-mail addresses as environment variables with names--

* %(sender_env_name)s
* %(test_env_name)s

The environment variables, if set, take precedence over the script constants.

Behavior:

The parent directory of the given directory should have a name matching
the name of the puzzle being submitted, for example facebook/hoppity/python
or puzzles/meepmeep/c.  The script pulls the puzzle name from the parent
directory.

The script attaches at most two files, as follows:

(1) If the given directory contains a file called "Makefile" (case-sensitive),
    the script attaches the makefile.  Otherwise, the script searches for
    a file in the given directory whose name matches the name of the puzzle
    being submitted (i.e. the puzzle executable), and it attaches that.

(2) Optionally, the given directory can include a subdirectory called "%(lib_folder)s".
    If this directory exists, the script tars, gzips, and attaches this
    directory as a file called "%(lib_folder)s.tar.gz".

Sample directory hierarchies for a scripting language and a compiled
language are as follows:

hoppity/python
    hoppity (executable)
    lib
        __init__.py
        hoppity.py

meepmeep/c
    Makefile
    lib
        meepmeep.c""" % {"lib_folder": LIB_DIRECTORY_NAME,
                         "sender_env_name": SENDER_ENV_NAME,
                         "test_env_name": TEST_ENV_NAME}


class Error(Exception):
    """Base class for exceptions in this module."""
    pass


def configure_logging(logging_level=None):
    if logging_level is None:
        logging_level = logging.INFO

    logger = logging.getLogger()  # the root logger.

    stream = sys.stderr
    handler = logging.StreamHandler(stream)
    formatter = logging.Formatter("[%(levelname)s] %(message)s")
    handler.setFormatter(formatter)

    logger.setLevel(logging_level)
    logger.addHandler(handler)

    _log.debug("Debug logging enabled.")


def read_user_configuration():
    """
    Check and return the user-specified configuration values.

    Returns:
      (sender_address, test_submission_address)

    """
    sender_address = os.getenv(SENDER_ENV_NAME, SENDER_EMAIL_ADDRESS)
    test_submission_address = os.getenv(TEST_ENV_NAME, TEST_EMAIL_ADDRESS)

    if not sender_address:
        raise Error("""The e-mail address to send from has not been configured.

Follow the setup instructions in the help documentation, and configure the
sender e-mail address before using this script.""")

    if not test_submission_address:
        raise Error("""The test e-mail address has not been configured.

Follow the setup instructions in the help documentation, and configure the
test submission e-mail address before using this script.""")

    _log.debug('User-configuration: read sender address: "%s"' % sender_address)
    _log.debug('User-configuration: read test address: "%s"' % test_submission_address)

    return (sender_address, test_submission_address)


def create_parser(usage, args):
    parser = OptionParser(usage=usage)

    parser.add_option("--real", dest="is_real", action="store_true", default=False,
                      help="send a real submission to Facebook.  Otherwise, "
                           "send the submission to the test e-mail address.")
    parser.add_option("-m", "--message", dest="message", metavar="MESSAGE",
                      help="include this message text in the e-mail body")
    parser.add_option(DEBUG_OPTION, dest="verbose", action="store_true",
                      help="log verbosely")

    return parser


def check_submission_directory(submission_directory):
    """Check the submission directory, and return the puzzle name."""
    # Convert to a normalized absolute path to determine the name of the
    # parent directory.  Normalizing also strips off any trailing
    # slashes (e.g. "hoppity/c/").  Otherwise, calling os.path.basename()
    # can result in a base name that is an empty string.
    submission_directory = os.path.abspath(submission_directory)

    if not os.path.isdir(submission_directory):
        raise Error("The submission directory is not a path to a "
                    "directory: %s" % submission_directory)

    puzzle_directory = os.path.dirname(submission_directory)
    puzzle_name = os.path.basename(puzzle_directory)

    if puzzle_name not in VALID_PUZZLE_NAMES:
        raise Error('The name of the parent directory "%s" does not match '
                    "the name of a puzzle in the script's list of valid "
                    "puzzle names:\n\n   %s\n\n"
                    "If necessary, correct the script's VALID_PUZZLE_NAMES "
                    "constant." %
                    (puzzle_name, "\n   ".join(VALID_PUZZLE_NAMES)))

    return puzzle_name


def should_exclude_from_tar(path):
    """Return whether to exclude the given path from the tar file."""
    for extension in EXCLUDE_FROM_TAR:
        if path.endswith(extension):
            return True

    base_name = os.path.basename(path)
    if base_name.startswith("."):
        return True

    return False


def create_tar_gz(source_directory):
    """
    Create a tar file of the given source directory.

    This function creates the tar file in the same directory as the
    directory containing the source directory.  The name of the tar
    file is *.tar.gz, where * is the base name of the given source
    directory.

    """
    _log.debug("Creating tar of: %s" % source_directory)

    # Strip off any trailing slashes.
    source_directory = os.path.normpath(source_directory)

    directory_name = os.path.basename(source_directory)
    characters_to_strip = len(source_directory) - len(directory_name)

    # Write the tar file into the same directory as the source directory
    # (so that *.tar.gz is a sibling of what is being tarred).
    target_path = "%s.tar.gz" % source_directory

    try:
        _log.debug("Writing tar to: %s" % target_path)
        tar = tarfile.open(name=target_path, mode="w:gz")

        for result in os.walk(source_directory):
            dir_path = result[0]
            for file_name in result[2]:
                path_to_add = os.path.join(dir_path, file_name)
                path_to_add = os.path.normpath(path_to_add)

                if should_exclude_from_tar(path_to_add):
                    _log.debug("Excluding from tar: %s" % path_to_add)
                    continue

                arc_name = path_to_add[characters_to_strip:]

                # If we don't include the arcname parameter, then the source
                # directory can extract into a subdirectory of the newly
                # created directory, depending on the current working directory.
                _log.debug('Adding to tar: %s' % arc_name)
                tar.add(path_to_add, arcname=arc_name)
    finally:
        tar.close()

    return target_path


def prep_attachments(puzzle_name, submission_directory):
    """
    Return a list of paths of the files to attach.

    This function also creates the tar file, if necessary.

    """
    attachment_paths = []

    # We include a script executable or a Makefile, but not both.
    makefile_path = os.path.join(submission_directory, "Makefile")

    if os.path.exists(makefile_path):
        _log.debug("Found makefile: %s" % makefile_path)
        file_path = makefile_path
    else:
        _log.debug('No makefile found; searching for puzzle executable instead.')
        executable_path = os.path.join(submission_directory, puzzle_name)
        if not os.path.exists(executable_path) or not os.path.isfile(executable_path):
            raise Error("Neither a makefile nor a puzzle executable found:\n"
                            "%s\n%s" % (makefile_path, executable_path))
        _log.debug("Found executable: %s" % executable_path)
        file_path = executable_path

    attachment_paths.append(file_path)

    # Add library folder.
    lib_directory = os.path.join(submission_directory, LIB_DIRECTORY_NAME)

    if not os.path.exists(lib_directory):
        _log.debug('No library directory "%s" found: skipping' % LIB_DIRECTORY_NAME)
    else:
        attachment_path = create_tar_gz(source_directory=lib_directory)
        attachment_paths.append(attachment_path)
        _log.debug("Created attachment at: %s" % attachment_path)

    return attachment_paths


def add_attachment(mime_multipart, attachment_path):
    """Add an attachment to the given MIMEMultipart instance."""
    part = MIMEBase('application', 'octet-stream')
    part.set_payload(open(attachment_path, 'rb').read())
    Encoders.encode_base64(part)
    part.add_header('Content-Disposition',
                    'attachment; filename="%s"' % os.path.basename(attachment_path))
    mime_multipart.attach(part)


def mail(sender_address, sender_pwd, mail_tos, subject, body, attachment_paths):
    """Send an e-mail."""
    mail_ccs = [sender_address]
    mail_recipients = mail_tos + mail_ccs

    multi = MIMEMultipart()

    multi['From'] = sender_address
    multi['To'] = COMMASPACE.join(mail_tos)
    multi['Cc'] = COMMASPACE.join(mail_ccs)
    multi['Subject'] = subject

    multi.attach(MIMEText(body))

    for attachment_path in attachment_paths:
        _log.debug("Adding attachment to e-mail: %s" % attachment_path)
        add_attachment(multi, attachment_path)

    mailServer = smtplib.SMTP(SMTP_HOST, SMTP_PORT)
    mailServer.ehlo()
    mailServer.starttls()
    mailServer.ehlo()

    _log.info('Logging in as: %s...' % sender_address)
    mailServer.login(sender_address, sender_pwd)
    _log.info('Sending mail to: %s...' % str(mail_recipients))
    mailServer.sendmail(sender_address, mail_recipients, multi.as_string())

    mailServer.close()


def submit_solution(args):
    """Submit a puzzle solution to the Facebook PuzzleBot."""
    parser = create_parser(usage=USAGE, args=args)
    (options, args) = parser.parse_args(args)

    sender_address, test_submission_address = read_user_configuration()

    if not args:
        raise Error("You must provide a submission directory.")
    submission_directory = args[0]

    submission_address = (REAL_SUBMISSION_ADDRESS if options.is_real else
                          test_submission_address)
    message = options.message if options.message else ""

    puzzle_name = check_submission_directory(submission_directory)
    attachment_paths = prep_attachments(puzzle_name, submission_directory)

    print 'Submitting puzzle "%s" to %s with--' % (puzzle_name, submission_address)
    print "Message: %s" % message
    print "Attachments: %s" % str(attachment_paths)

    sender_pwd = getpass.getpass(prompt="Password for %s: " % sender_address)

    email_body = "Facebook PuzzleBot submission: %s\n" % message

    mail(sender_address=sender_address,
         sender_pwd=sender_pwd,
         mail_tos=[submission_address],
         subject=puzzle_name,
         body=email_body,
         attachment_paths=attachment_paths)


def exit_with_error(message):
    """Display an error message, and exit the program."""
    print """
ERROR: %s

Pass -h or --help for help documentation and available options.""" % message
    exit(1)


def main(sys_argv):
    args = sys_argv[1:]

    # Configure logging prior to parsing options.
    configure_logging(logging.DEBUG if DEBUG_OPTION in args else None)

    try:
        submit_solution(args)
    except KeyboardInterrupt, err:
        exit_with_error("Script aborted by user.")
    except Error, err:
        exit_with_error(err.message)


if __name__ == "__main__":
    result = main(sys.argv)

    sys.exit(result)
